import {Directory, ExportedDeclarations, Node, Project, SourceFile, Type} from "ts-morph";
import {resolve, dirname, relative} from "node:path";
import {groupBy, uniqBy} from "lodash-es";

/**
 * Barebones treeshake-optimized index.js barrel file generator. This file will generate one index.js file in every subdirectory
 * of the project, exporting the named exports at that level, plus the named exports of all its children. This way, users can
 * import named exports at any level of the project, allowing bundlers to properly bundle only the code actually used.
 */

interface Symbol {
	t: string,
	m: SourceFile,
	type: Type,
	decl: ExportedDeclarations
}

/**
 * Determines if this should be exported as a type, or as a module export.
 * @param decl
 */
function isTypescriptConstruct(decl: ExportedDeclarations) {
	return !Node.isClassDeclaration(decl) && !Node.isVariableDeclaration(decl) && !Node.isEnumDeclaration(decl) && !Node.isFunctionDeclaration(decl);
}

function buildIndexForDirectory(directory: Directory): Symbol[] {
	let symbols = [] as Symbol[];
	const children = directory.getDirectories();
	const source = directory.createSourceFile("index.ts", '', {overwrite: true});

	source.addStatements(writer => {
		writer.writeLine('/**')
		writer.writeLine(`* @Generated by optimize-treeshake.ts on ${new Date().toISOString()}`)
		writer.writeLine('* This file exports all known public members from itself and all descendant children, a process known as creating a "Barrel" file.')
		writer.writeLine('* Do not make changes to this file. All changes will be overwritten on every build.')
		writer.writeLine('*/');
		writer.blankLine();
	})

	symbols.push(...children.flatMap(child => {
		return buildIndexForDirectory(child);
	}))

	const sources = directory.getSourceFiles();
	sources.forEach(source => {
		const declSet = source.getExportedDeclarations();
		for (let k of declSet.keys()) {
			const decls = declSet.get(k);
			decls.forEach(decl => {
				symbols.push({
					t: k,
					m: decl.getSourceFile(),
					type: decl.getType(),
					decl: decl
				})
			})
		}
	})

	symbols = uniqBy(symbols, s => s.t);

	const groups :Record<string, Symbol[]> = groupBy(symbols, s => {
		return s['m'].getFilePath();
	})

	Object.keys(groups).forEach(key => {
		const symbolGroup = groups[key];
		source.addExportDeclaration({
			namedExports: symbolGroup.map(s => {
				return {"name": s.t, isTypeOnly: isTypescriptConstruct(s.decl)}
			}),
			moduleSpecifier: directory.getRelativePathAsModuleSpecifierTo(key)
		})
	})

	source.saveSync();
	return symbols;
}



const root = resolve(dirname(__filename), "..");

const project = new Project({
	tsConfigFilePath: resolve(root, "tsconfig.json"),
})

project.getRootDirectories().forEach(directory => {
	buildIndexForDirectory(directory);
})
