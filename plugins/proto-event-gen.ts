import {Project, VariableDeclarationKind, Writers} from "ts-morph";
import {dirname, resolve} from "node:path";
import {EngineRequestSchema, EngineResponseSchema} from "../src/proto/engine_pb";
import {type DescMessage, getOption, type Message} from "@bufbuild/protobuf";
import {event_name} from "../src/proto/event_pb";
import type {GenMessage} from "@bufbuild/protobuf/codegenv2";
import {kebabCase} from "lodash-es";

/**
 * This file is generating protobuf event names from the proto files themselves, and code generating the typescript definition files
 * for type-safe event compilation.
 */

function removeFromString(words: string[], str: string) {
    return words.reduce((result, word) => result.replace(word, ''), str)
}

function quoteLiteral(source: string) {
	return `"${source}"`
}

export interface EventMapping {
	eventName: string;
	type: string;
	name: string;
	m: DescMessage;
	namespace: 'request' | 'response',
	parent: GenMessage<any>
}

function generateEventNames<T extends Message>(m: GenMessage<T>, oneof: 'request' | 'response'): EventMapping[] {

    const options = m.fields.filter(f => f.oneof != null && f.oneof.name === oneof);

    return options.map(option => {
        let eventName = getOption(option.message as DescMessage, event_name);

        if (eventName.length === 0) {
            eventName = removeFromString(["Request", "Response"], option.proto.typeName);
            eventName = kebabCase(eventName).replace(/-/g, '.');
        }

        return {eventName, type: m.typeName as string, m: option.message as DescMessage, namespace: oneof, parent: m, name: option.jsonName};
    });
}

// @ts-ignore
const root = resolve(dirname(__filename), "..");

const project = new Project({
    tsConfigFilePath: resolve(root, "tsconfig.json"),
});

const response = generateEventNames(EngineResponseSchema, "response");
const request = generateEventNames(EngineRequestSchema, "request");

const source = project.createSourceFile(resolve(root, "src", "types", "event.types.ts"), '', {overwrite: true})

source.addStatements((writer) => {
	writer.writeLine("/**")
	writer.writeLine("* " + "@generated " + new Date() + "\n")
	writer.writeLine("* This file has been generated to create a repository of proto bindings and information so that consumers of the layout engine do not need to")
	writer.writeLine("* know or understand fundamental proto constructs. This also insulates developers from changing event specifications.");
	writer.writeLine("*");
	writer.writeLine("* DO NOT EDIT THIS FILE: It will be regenerated. To make permanent modifications, @see <root>/plugins/proto-event-gen.ts")
	writer.writeLine("*/")
	writer.newLine();
});

source.addImportDeclarations([{
	namedImports: [{
		name: 'GenMessage',
		isTypeOnly: true
	}],
	moduleSpecifier: '@bufbuild/protobuf/codegenv2'
}, {
	namedImports: [
		{
			name: "Message",
			isTypeOnly: true
		}
	],
	moduleSpecifier: "@bufbuild/protobuf"
}])

source.addImportDeclarations([
	{
		namedImports: [
			{name: 'EngineRequestSchema'},
			{name: 'EngineResponseSchema'},
			{name: 'EngineRequest', isTypeOnly: true},
			{name: 'EngineResponse', isTypeOnly: true},
		],
		moduleSpecifier: '@/proto/engine_pb'
	}
])

source.addTypeAlias({
	name: "EngineRequestProtoMessageTypes",
	isExported: true,
	type: 'EngineRequest["request"]["value"]'
})

source.addTypeAlias({
	name: "EngineRequestProtoTypes",
	isExported: true,
	type: 'EngineRequest["request"]["case"]'
})

source.addTypeAlias({
	name: "EngineResponseProtoMessageTypes",
	isExported: true,
	type: 'EngineResponse["response"]["value"]'
})

source.addTypeAlias({
	name: "EngineResponseProtoTypes",
	isExported: true,
	type: 'EngineResponse["response"]["case"]'
})

source.addTypeAlias({
	name: "EngineProtoTypes",
	isExported: true,
	type: 'EngineRequestProtoTypes | EngineResponseProtoTypes'
})

source.addTypeAlias({
	name: "EngineMessageTypes",
	isExported: true,
	type: 'EngineRequestProtoMessageTypes | EngineResponseProtoMessageTypes'
})

source.addTypeAlias({
	name: 'EngineRequestEventTypes',
	isExported: true,
	type: request.map(r => quoteLiteral(r.eventName)).join(' | ')
})

source.addTypeAlias({
	name: 'EngineResponseEventTypes',
	isExported: true,
	type: response.map(r => quoteLiteral(r.eventName)).join(' | ')
})

source.addTypeAlias({
	name: 'EngineEventTypes',
	isExported: true,
	type: 'EngineRequestEventTypes | EngineResponseEventTypes'
})

const schema = source.addInterface({
	name: "EventSchema",
	isExported: true,
})

schema.addProperty({
	name: "schema",
	type: 'GenMessage<Message<any>>'
})

schema.addProperty({
	name: 'namespace',
	type: '"request" | "response"'
})

schema.addProperty({
	name: "parent",
	type: 'GenMessage<Message<any>>'
})

schema.addProperty({
	name: "name",
	type: "EngineProtoTypes"
})

schema.addProperty({
	name: "event",
	type: "EngineEventTypes"
})

const mappings = [...request, ...response];
const obj: Record<string, string> = {};
const inverse: Record<string, string> = {};

mappings.forEach(mapping => {
	const schema =`${mapping.m.typeName}Schema`
	source.addImportDeclaration({
		namedImports: [{
			name: schema,
		}],
		moduleSpecifier: `@/proto/${mapping.m.file.name}_pb`
	})

	source.addVariableStatement({
		isExported: false,
		declarationKind: VariableDeclarationKind.Const,
		declarations: [{
			name: `${mapping.m.typeName}Mapping`,
			initializer: Writers.object({
				schema,
				namespace: quoteLiteral(mapping.namespace),
				parent: `${mapping.parent.typeName}Schema`,
				name: quoteLiteral(mapping.name),
				event: quoteLiteral(mapping.eventName)
			}),
			type: 'EventSchema'
		}]
	})

	inverse[`"${mapping.name}"`] = `${mapping.m.typeName}Mapping`;
	obj[`"${mapping.eventName}"`] = `${mapping.m.typeName}Mapping`;
})

source.addVariableStatement({
	isExported: true,
	declarationKind: VariableDeclarationKind.Const,
	declarations: [{
		name: 'EngineEventMapping',
		initializer: Writers.object(obj)
	}]
})

source.addVariableStatement({
	isExported: true,
	declarationKind: VariableDeclarationKind.Const,
	declarations: [{
		name: 'EngineEventInverseMapping',
		initializer: Writers.object(inverse)
	}]
})


source.saveSync();
